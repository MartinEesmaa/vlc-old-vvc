diff --git a/configure b/configure
index 89af70d..7250330 100644
--- a/configure
+++ b/configure
@@ -228,6 +228,7 @@ External library support:
   --enable-libcdio         enable audio CD grabbing with libcdio [no]
   --enable-libcodec2       enable codec2 en/decoding using libcodec2 [no]
   --enable-libdav1d        enable AV1 decoding via libdav1d [no]
+  --enable-libvvdec        enable VVC decoding via vvdec [no]
   --enable-libdavs2        enable AVS2 decoding via libdavs2 [no]
   --enable-libdc1394       enable IIDC-1394 grabbing using libdc1394
                            and libraw1394 [no]
@@ -1772,6 +1773,7 @@ EXTERNAL_LIBRARY_LIST="
     libcelt
     libcodec2
     libdav1d
+    libvvdec
     libdc1394
     libdrm
     libflite
@@ -1793,6 +1795,7 @@ EXTERNAL_LIBRARY_LIST="
     libopenh264
     libopenjpeg
     libopenmpt
+    libvvdec
     libopenvino
     libopus
     libpulse
@@ -2358,6 +2361,7 @@ CONFIG_EXTRA="
     cbs_av1
     cbs_h264
     cbs_h265
+    cbs_h266
     cbs_jpeg
     cbs_mpeg2
     cbs_vp9
@@ -2626,6 +2630,7 @@ threads_if_any="$THREADS_LIST"
 cbs_av1_select="cbs"
 cbs_h264_select="cbs"
 cbs_h265_select="cbs"
+cbs_h266_select="cbs"
 cbs_jpeg_select="cbs"
 cbs_mpeg2_select="cbs"
 cbs_vp9_select="cbs"
@@ -3169,6 +3174,7 @@ mpegaudio_parser_select="mpegaudioheader"
 mpegvideo_parser_select="mpegvideo"
 mpeg4video_parser_select="h263dsp mpegvideo qpeldsp"
 vc1_parser_select="vc1dsp"
+vvc_parser_select="cbs_h266"
 
 # bitstream_filters
 aac_adtstoasc_bsf_select="adts_header"
@@ -3185,6 +3191,7 @@ mjpeg2jpeg_bsf_select="jpegtables"
 mpeg2_metadata_bsf_select="cbs_mpeg2"
 trace_headers_bsf_select="cbs"
 vp9_metadata_bsf_select="cbs_vp9"
+vvc_metadata_bsf_select="cbs_h266"
 
 # external libraries
 aac_at_decoder_deps="audiotoolbox"
@@ -3235,7 +3242,8 @@ libcelt_decoder_deps="libcelt"
 libcodec2_decoder_deps="libcodec2"
 libcodec2_encoder_deps="libcodec2"
 libdav1d_decoder_deps="libdav1d"
-libdav1d_decoder_select="atsc_a53"
+libvvdec_decoder_deps="libvvdec"
+libvvdec_decoder_select="vvc_mp4toannexb_bsf"
 libdavs2_decoder_deps="libdavs2"
 libfdk_aac_decoder_deps="libfdk_aac"
 libfdk_aac_encoder_deps="libfdk_aac"
@@ -3350,7 +3358,7 @@ mp3_demuxer_select="mpegaudio_parser"
 mp3_muxer_select="mpegaudioheader"
 mp4_muxer_select="mov_muxer"
 mpegts_demuxer_select="iso_media"
-mpegts_muxer_select="ac3_parser adts_muxer latm_muxer h264_mp4toannexb_bsf hevc_mp4toannexb_bsf"
+mpegts_muxer_select="ac3_parser adts_muxer latm_muxer h264_mp4toannexb_bsf hevc_mp4toannexb_bsf vvc_mp4toannexb_bsf"
 mpegtsraw_demuxer_select="mpegts_demuxer"
 mxf_muxer_select="golomb pcm_rechunk_bsf"
 mxf_d10_muxer_select="mxf_muxer"
@@ -6362,6 +6370,7 @@ enabled libcelt           && require libcelt celt/celt.h celt_decode -lcelt0 &&
 enabled libcaca           && require_pkg_config libcaca caca caca.h caca_create_canvas
 enabled libcodec2         && require libcodec2 codec2/codec2.h codec2_create -lcodec2
 enabled libdav1d          && require_pkg_config libdav1d "dav1d >= 0.5.0" "dav1d/dav1d.h" dav1d_version
+enabled libvvdec          && require_pkg_config libvvdec "libvvdec >= 1.1.0" "vvdec/vvdec.h" vvdec_get_version
 enabled libdavs2          && require_pkg_config libdavs2 "davs2 >= 1.6.0" davs2.h davs2_decoder_open
 enabled libdc1394         && require_pkg_config libdc1394 libdc1394-2 dc1394/dc1394.h dc1394_new
 enabled libdrm            && require_pkg_config libdrm libdrm xf86drm.h drmGetVersion
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index b3d284d..a7b2ae3 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -74,6 +74,7 @@ OBJS-$(CONFIG_CBS)                     += cbs.o cbs_bsf.o
 OBJS-$(CONFIG_CBS_AV1)                 += cbs_av1.o
 OBJS-$(CONFIG_CBS_H264)                += cbs_h2645.o cbs_sei.o h2645_parse.o
 OBJS-$(CONFIG_CBS_H265)                += cbs_h2645.o cbs_sei.o h2645_parse.o
+OBJS-$(CONFIG_CBS_H266)                += cbs_h2645.o cbs_sei.o h2645_parse.o
 OBJS-$(CONFIG_CBS_JPEG)                += cbs_jpeg.o
 OBJS-$(CONFIG_CBS_MPEG2)               += cbs_mpeg2.o
 OBJS-$(CONFIG_CBS_VP9)                 += cbs_vp9.o
@@ -1028,6 +1029,7 @@ OBJS-$(CONFIG_LIBCELT_DECODER)            += libcelt_dec.o
 OBJS-$(CONFIG_LIBCODEC2_DECODER)          += libcodec2.o codec2utils.o
 OBJS-$(CONFIG_LIBCODEC2_ENCODER)          += libcodec2.o codec2utils.o
 OBJS-$(CONFIG_LIBDAV1D_DECODER)           += libdav1d.o
+OBJS-$(CONFIG_LIBVVDEC_DECODER)           += libvvdec.o
 OBJS-$(CONFIG_LIBDAVS2_DECODER)           += libdavs2.o
 OBJS-$(CONFIG_LIBFDK_AAC_DECODER)         += libfdk-aacdec.o
 OBJS-$(CONFIG_LIBFDK_AAC_ENCODER)         += libfdk-aacenc.o
@@ -1131,6 +1133,7 @@ OBJS-$(CONFIG_VC1_PARSER)              += vc1_parser.o vc1.o vc1data.o  \
 OBJS-$(CONFIG_VP3_PARSER)              += vp3_parser.o
 OBJS-$(CONFIG_VP8_PARSER)              += vp8_parser.o
 OBJS-$(CONFIG_VP9_PARSER)              += vp9_parser.o
+OBJS-$(CONFIG_VVC_PARSER)              += vvc_parser.o
 OBJS-$(CONFIG_WEBP_PARSER)             += webp_parser.o
 OBJS-$(CONFIG_XBM_PARSER)              += xbm_parser.o
 OBJS-$(CONFIG_XMA_PARSER)              += xma_parser.o
@@ -1153,6 +1156,7 @@ OBJS-$(CONFIG_H264_REDUNDANT_PPS_BSF)     += h264_redundant_pps_bsf.o
 OBJS-$(CONFIG_HAPQA_EXTRACT_BSF)          += hapqa_extract_bsf.o hap.o
 OBJS-$(CONFIG_HEVC_METADATA_BSF)          += h265_metadata_bsf.o h265_profile_level.o
 OBJS-$(CONFIG_HEVC_MP4TOANNEXB_BSF)       += hevc_mp4toannexb_bsf.o
+OBJS-$(CONFIG_VVC_MP4TOANNEXB_BSF)        += vvc_mp4toannexb_bsf.o
 OBJS-$(CONFIG_IMX_DUMP_HEADER_BSF)        += imx_dump_header_bsf.o
 OBJS-$(CONFIG_MJPEG2JPEG_BSF)             += mjpeg2jpeg_bsf.o
 OBJS-$(CONFIG_MJPEGA_DUMP_HEADER_BSF)     += mjpega_dump_header_bsf.o
@@ -1175,6 +1179,7 @@ OBJS-$(CONFIG_VP9_METADATA_BSF)           += vp9_metadata_bsf.o
 OBJS-$(CONFIG_VP9_RAW_REORDER_BSF)        += vp9_raw_reorder_bsf.o
 OBJS-$(CONFIG_VP9_SUPERFRAME_BSF)         += vp9_superframe_bsf.o
 OBJS-$(CONFIG_VP9_SUPERFRAME_SPLIT_BSF)   += vp9_superframe_split_bsf.o
+OBJS-$(CONFIG_VVC_METADATA_BSF)           += h266_metadata_bsf.o
 
 # thread libraries
 OBJS-$(HAVE_LIBC_MSVCRT)               += file_open.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index 2e9a358..28b69d9 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -29,6 +29,7 @@
 #include "avcodec.h"
 #include "version.h"
 
+extern AVCodec ff_libvvdec_decoder;
 extern AVCodec ff_a64multi_encoder;
 extern AVCodec ff_a64multi5_encoder;
 extern AVCodec ff_aasc_decoder;
diff --git a/libavcodec/bitstream_filters.c b/libavcodec/bitstream_filters.c
index 02d33ab..41b1824 100644
--- a/libavcodec/bitstream_filters.c
+++ b/libavcodec/bitstream_filters.c
@@ -36,6 +36,7 @@ extern const AVBitStreamFilter ff_extract_extradata_bsf;
 extern const AVBitStreamFilter ff_filter_units_bsf;
 extern const AVBitStreamFilter ff_h264_metadata_bsf;
 extern const AVBitStreamFilter ff_h264_mp4toannexb_bsf;
+extern const AVBitStreamFilter ff_vvc_mp4toannexb_bsf;
 extern const AVBitStreamFilter ff_h264_redundant_pps_bsf;
 extern const AVBitStreamFilter ff_hapqa_extract_bsf;
 extern const AVBitStreamFilter ff_hevc_metadata_bsf;
@@ -61,6 +62,7 @@ extern const AVBitStreamFilter ff_vp9_metadata_bsf;
 extern const AVBitStreamFilter ff_vp9_raw_reorder_bsf;
 extern const AVBitStreamFilter ff_vp9_superframe_bsf;
 extern const AVBitStreamFilter ff_vp9_superframe_split_bsf;
+extern const AVBitStreamFilter ff_vvc_metadata_bsf;
 
 #include "libavcodec/bsf_list.c"
 
diff --git a/libavcodec/cbs.c b/libavcodec/cbs.c
index c7f6984..17f2128 100644
--- a/libavcodec/cbs.c
+++ b/libavcodec/cbs.c
@@ -39,6 +39,9 @@ static const CodedBitstreamType *const cbs_type_table[] = {
 #if CONFIG_CBS_H265
     &ff_cbs_type_h265,
 #endif
+#if CONFIG_CBS_H266
+    &ff_cbs_type_h266,
+#endif
 #if CONFIG_CBS_JPEG
     &ff_cbs_type_jpeg,
 #endif
@@ -60,6 +63,9 @@ const enum AVCodecID ff_cbs_all_codec_ids[] = {
 #if CONFIG_CBS_H265
     AV_CODEC_ID_H265,
 #endif
+#if CONFIG_CBS_H266
+    AV_CODEC_ID_H266,
+#endif
 #if CONFIG_CBS_JPEG
     AV_CODEC_ID_MJPEG,
 #endif
diff --git a/libavcodec/cbs_h2645.c b/libavcodec/cbs_h2645.c
index 6005d46..c08a76e 100644
--- a/libavcodec/cbs_h2645.c
+++ b/libavcodec/cbs_h2645.c
@@ -24,12 +24,18 @@
 #include "cbs_internal.h"
 #include "cbs_h264.h"
 #include "cbs_h265.h"
+#include "cbs_h266.h"
 #include "h264.h"
 #include "h264_sei.h"
 #include "h2645_parse.h"
 #include "hevc.h"
 #include "hevc_sei.h"
+#include "vvc.h"
 
+static av_always_inline unsigned int h266_ceil(unsigned int v, unsigned int align)
+{
+    return (((v) + (align) - 1) / (align));
+}
 
 static int cbs_read_ue_golomb(CodedBitstreamContext *ctx, GetBitContext *gbc,
                               const char *name, const int *subscripts,
@@ -257,6 +263,7 @@ static int cbs_h265_payload_extension_present(GetBitContext *gbc, uint32_t paylo
 #define FUNC_NAME1(rw, codec, name) FUNC_NAME2(rw, codec, name)
 #define FUNC_H264(name) FUNC_NAME1(READWRITE, h264, name)
 #define FUNC_H265(name) FUNC_NAME1(READWRITE, h265, name)
+#define FUNC_H266(name) FUNC_NAME1(READWRITE, h266, name)
 #define FUNC_SEI(name)  FUNC_NAME1(READWRITE, sei,  name)
 
 #define SUBSCRIPTS(subs, ...) (subs > 0 ? ((int[subs + 1]){ subs, __VA_ARGS__ }) : NULL)
@@ -371,6 +378,10 @@ static int cbs_h2645_read_more_rbsp_data(GetBitContext *gbc)
 #include "cbs_h265_syntax_template.c"
 #undef FUNC
 
+#define FUNC(name) FUNC_H266(name)
+#include "cbs_h266_syntax_template.c"
+#undef FUNC
+
 #undef READ
 #undef READWRITE
 #undef RWContext
@@ -449,6 +460,10 @@ static int cbs_h2645_read_more_rbsp_data(GetBitContext *gbc)
 #include "cbs_h265_syntax_template.c"
 #undef FUNC
 
+#define FUNC(name) FUNC_H266(name)
+#include "cbs_h266_syntax_template.c"
+#undef FUNC
+
 #undef WRITE
 #undef READWRITE
 #undef RWContext
@@ -478,8 +493,9 @@ static int cbs_h2645_fragment_add_nals(CodedBitstreamContext *ctx,
         const H2645NAL *nal = &packet->nals[i];
         AVBufferRef *ref;
         size_t size = nal->size;
+        enum AVCodecID codec_id = ctx->codec->codec_id;
 
-        if (nal->nuh_layer_id > 0)
+        if (codec_id != AV_CODEC_ID_VVC && nal->nuh_layer_id > 0)
             continue;
 
         // Remove trailing zeroes.
@@ -515,6 +531,12 @@ static int cbs_h2645_split_fragment(CodedBitstreamContext *ctx,
     if (frag->data_size == 0)
         return 0;
 
+    if (codec_id == AV_CODEC_ID_VVC) {
+        //we deactive picture header here to avoid reuse previous au's ph.
+        CodedBitstreamH266Context *h266 = ctx->priv_data;
+        h266->priv.ph = NULL;
+    }
+
     if (header && frag->data[0] && codec_id == AV_CODEC_ID_H264) {
         // AVCC header.
         size_t size, start, end;
@@ -661,38 +683,142 @@ static int cbs_h2645_split_fragment(CodedBitstreamContext *ctx,
     return 0;
 }
 
-#define cbs_h2645_replace_ps(h26n, ps_name, ps_var, id_element) \
-static int cbs_h26 ## h26n ## _replace_ ## ps_var(CodedBitstreamContext *ctx, \
-                                                  CodedBitstreamUnit *unit)  \
-{ \
-    CodedBitstreamH26 ## h26n ## Context *priv = ctx->priv_data; \
-    H26 ## h26n ## Raw ## ps_name *ps_var = unit->content; \
-    unsigned int id = ps_var->id_element; \
-    int err; \
-    if (id >= FF_ARRAY_ELEMS(priv->ps_var)) { \
-        av_log(ctx->log_ctx, AV_LOG_ERROR, "Invalid " #ps_name \
-               " id : %d.\n", id); \
-        return AVERROR_INVALIDDATA; \
-    } \
-    err = ff_cbs_make_unit_refcounted(ctx, unit); \
-    if (err < 0) \
-        return err; \
-    if (priv->ps_var[id] == priv->active_ ## ps_var) \
-        priv->active_ ## ps_var = NULL ; \
-    av_buffer_unref(&priv->ps_var ## _ref[id]); \
-    av_assert0(unit->content_ref); \
-    priv->ps_var ## _ref[id] = av_buffer_ref(unit->content_ref); \
-    if (!priv->ps_var ## _ref[id]) \
-        return AVERROR(ENOMEM); \
-    priv->ps_var[id] = (H26 ## h26n ## Raw ## ps_name *)priv->ps_var ## _ref[id]->data; \
-    return 0; \
+static int cbs_h2645_replace_ps(CodedBitstreamContext *ctx,
+                                CodedBitstreamUnit *unit)
+{
+    typedef struct {
+        // Codec this parameter set exists in.
+        enum AVCodecID codec_id;
+        // The NAL unit type corresponding to this parameter set type.
+        int    nal_unit_type;
+        // Name of the parameter set.  This field is large enough to
+        // contain a string of the form "XPS".
+        char   name[4];
+        // The maximum number of this type of parameter set which might
+        // be stored.  The greatest valid id is also one less than this.
+        int    id_count;
+        // Offset of the ID field (uint8_t) in the decomposed raw
+        // parameter set structure.
+        size_t id_offset;
+        // Offset of the reference array (AVBufferRef*[]) in the codec
+        // private context.
+        size_t ref_array_offset;
+        // Offset of the pointer array (CodecRawXPS*[]) in the codec
+        // private context.
+        size_t ptr_array_offset;
+        // Offset of the active field (const CodecRawXPS*) in the codec
+        // private context, or zero if this codec does not have active
+        // parameter sets.
+        size_t active_offset;
+    } PSType;
+
+#define H2645_PS_TYPE(codec, nal, cname, uname, count, id_name, active_field) { \
+        .codec_id         = AV_CODEC_ID_ ## codec, \
+        .nal_unit_type    = nal, \
+        .name             = #cname, \
+        .id_count         = count, \
+        .id_offset        = offsetof(codec ## Raw ## cname, \
+                                     id_name ## _parameter_set_id), \
+        .ref_array_offset = offsetof(CodedBitstream ## codec ## Context, \
+                                     uname ## _ref), \
+        .ptr_array_offset = offsetof(CodedBitstream ## codec ## Context, \
+                                     uname), \
+        .active_offset    = offsetof(CodedBitstream ## codec ## Context, \
+                                     active_field), \
+    }
+#define H264_PS_TYPE(cname, uname, id_name) \
+    H2645_PS_TYPE(H264, H264_NAL_ ## cname, cname, uname, \
+                  H264_MAX_ ## cname ## _COUNT, \
+                  id_name, active_ ## uname)
+#define H265_PS_TYPE(cname, uname, id_name) \
+    H2645_PS_TYPE(H265, HEVC_NAL_ ## cname, cname, uname, \
+                  HEVC_MAX_ ## cname ## _COUNT, \
+                  uname ## _ ## id_name, active_ ## uname)
+#define H266_PS_TYPE(cname, uname, id_name) \
+    H2645_PS_TYPE(H266, VVC_ ## cname ## _NUT, cname, uname, \
+                  VVC_MAX_ ## cname ## _COUNT, \
+                  uname ## _ ## id_name, common)
+
+    static const PSType ps_types[] = {
+        H264_PS_TYPE(SPS, sps, seq),
+        H264_PS_TYPE(PPS, pps, pic),
+        H265_PS_TYPE(VPS, vps, video),
+        H265_PS_TYPE(SPS, sps, seq),
+        H265_PS_TYPE(PPS, pps, pic),
+        H266_PS_TYPE(VPS, vps, video),
+        H266_PS_TYPE(SPS, sps, seq),
+        H266_PS_TYPE(PPS, pps, pic),
+    };
+
+    const PSType *ps_type;
+    AVBufferRef **ref_array;
+    void **ptr_array;
+    int err, id, i;
+
+    ps_type = NULL;
+    for (i = 0; i < FF_ARRAY_ELEMS(ps_types); i++) {
+        if (ps_types[i].codec_id == ctx->codec->codec_id &&
+            ps_types[i].nal_unit_type == unit->type) {
+            ps_type = &ps_types[i];
+            break;
+        }
+    }
+    av_assert0(ps_type);
+
+
+    id = *((uint8_t*)unit->content + ps_type->id_offset);
+
+    if (id >= ps_type->id_count) {
+        av_log(ctx->log_ctx, AV_LOG_ERROR, "Invalid %s id: %d.\n",
+            ps_type->name, id);
+        return AVERROR_INVALIDDATA;
+    }
+
+    err = ff_cbs_make_unit_refcounted(ctx, unit);
+    if (err < 0)
+        return err;
+
+    ref_array = (AVBufferRef**)((uint8_t*)ctx->priv_data +
+                                ps_type->ref_array_offset);
+    ptr_array = (void**)       ((uint8_t*)ctx->priv_data +
+                                ps_type->ptr_array_offset);
+
+    if (ps_type->active_offset) {
+        void **active = (void**)((uint8_t*)ctx->priv_data +
+                                 ps_type->active_offset);
+
+        if (ptr_array[id] == *active) {
+            // The old active parameter set is being overwritten, so it can't
+            // be active after this point.
+            *active = NULL;
+        }
+    }
+    av_buffer_unref(&ref_array[id]);
+
+    ref_array[id] = av_buffer_ref(unit->content_ref);
+    if (!ref_array[id])
+        return AVERROR(ENOMEM);
+    ptr_array[id] = ref_array[id]->data;
+
+    return 0;
 }
 
-cbs_h2645_replace_ps(4, SPS, sps, seq_parameter_set_id)
-cbs_h2645_replace_ps(4, PPS, pps, pic_parameter_set_id)
-cbs_h2645_replace_ps(5, VPS, vps, vps_video_parameter_set_id)
-cbs_h2645_replace_ps(5, SPS, sps, sps_seq_parameter_set_id)
-cbs_h2645_replace_ps(5, PPS, pps, pps_pic_parameter_set_id)
+static int cbs_h266_replace_ph(CodedBitstreamContext *ctx,
+                               CodedBitstreamUnit *unit)
+{
+    CodedBitstreamH266Context *h266 = ctx->priv_data;
+    int err;
+
+    h266->priv.ph = NULL;
+    err = ff_cbs_make_unit_refcounted(ctx, unit);
+    if (err < 0)
+        return err;
+    err = av_buffer_replace(&h266->priv.ph_ref, unit->content_ref);
+    if (err < 0)
+        return err;
+    h266->priv.ph = (H266RawPH*)h266->priv.ph_ref->data;
+    return 0;
+}
 
 static int cbs_h264_read_nal_unit(CodedBitstreamContext *ctx,
                                   CodedBitstreamUnit *unit)
@@ -717,7 +843,7 @@ static int cbs_h264_read_nal_unit(CodedBitstreamContext *ctx,
             if (err < 0)
                 return err;
 
-            err = cbs_h264_replace_sps(ctx, unit);
+            err = cbs_h2645_replace_ps(ctx, unit);
             if (err < 0)
                 return err;
         }
@@ -739,7 +865,7 @@ static int cbs_h264_read_nal_unit(CodedBitstreamContext *ctx,
             if (err < 0)
                 return err;
 
-            err = cbs_h264_replace_pps(ctx, unit);
+            err = cbs_h2645_replace_ps(ctx, unit);
             if (err < 0)
                 return err;
         }
@@ -836,7 +962,7 @@ static int cbs_h265_read_nal_unit(CodedBitstreamContext *ctx,
             if (err < 0)
                 return err;
 
-            err = cbs_h265_replace_vps(ctx, unit);
+            err = cbs_h2645_replace_ps(ctx, unit);
             if (err < 0)
                 return err;
         }
@@ -849,7 +975,7 @@ static int cbs_h265_read_nal_unit(CodedBitstreamContext *ctx,
             if (err < 0)
                 return err;
 
-            err = cbs_h265_replace_sps(ctx, unit);
+            err = cbs_h2645_replace_ps(ctx, unit);
             if (err < 0)
                 return err;
         }
@@ -863,7 +989,7 @@ static int cbs_h265_read_nal_unit(CodedBitstreamContext *ctx,
             if (err < 0)
                 return err;
 
-            err = cbs_h265_replace_pps(ctx, unit);
+            err = cbs_h2645_replace_ps(ctx, unit);
             if (err < 0)
                 return err;
         }
@@ -934,6 +1060,130 @@ static int cbs_h265_read_nal_unit(CodedBitstreamContext *ctx,
     return 0;
 }
 
+static int cbs_h266_read_nal_unit(CodedBitstreamContext *ctx,
+                                  CodedBitstreamUnit *unit)
+{
+    GetBitContext gbc;
+    int err;
+
+    err = init_get_bits8(&gbc, unit->data, unit->data_size);
+    if (err < 0)
+        return err;
+
+    err = ff_cbs_alloc_unit_content2(ctx, unit);
+    if (err < 0)
+        return err;
+
+    switch (unit->type) {
+    case VVC_VPS_NUT:
+        {
+            H266RawVPS *vps = unit->content;
+
+            err = cbs_h266_read_vps(ctx, &gbc, vps);
+            if (err < 0)
+                return err;
+
+            err = cbs_h2645_replace_ps(ctx, unit);
+            if (err < 0)
+                return err;
+        }
+        break;
+    case VVC_SPS_NUT:
+        {
+            H266RawSPS *sps = unit->content;
+
+            err = cbs_h266_read_sps(ctx, &gbc, sps);
+            if (err < 0)
+                return err;
+
+            err = cbs_h2645_replace_ps(ctx, unit);
+            if (err < 0)
+                return err;
+        }
+        break;
+
+    case VVC_PPS_NUT:
+        {
+            H266RawPPS *pps = unit->content;
+
+            err = cbs_h266_read_pps(ctx, &gbc, pps);
+            if (err < 0)
+                return err;
+
+            err = cbs_h2645_replace_ps(ctx, unit);
+            if (err < 0)
+                return err;
+        }
+        break;
+
+    case VVC_PH_NUT:
+        {
+            H266RawPH *ph = unit->content;
+            err = cbs_h266_read_ph(ctx, &gbc, ph);
+            if (err < 0)
+                return err;
+            err = cbs_h266_replace_ph(ctx, unit);
+            if (err < 0)
+                return err;
+        }
+        break;
+
+    case VVC_TRAIL_NUT:
+    case VVC_STSA_NUT:
+    case VVC_RADL_NUT:
+    case VVC_RASL_NUT:
+    case VVC_IDR_W_RADL:
+    case VVC_IDR_N_LP:
+    case VVC_CRA_NUT:
+    case VVC_GDR_NUT:
+        {
+            H266RawSlice *slice = unit->content;
+            int pos, len;
+
+            err = cbs_h266_read_slice_header(ctx, &gbc, &slice->header);
+            if (err < 0)
+                return err;
+
+            if (!cbs_h2645_read_more_rbsp_data(&gbc))
+                return AVERROR_INVALIDDATA;
+
+            pos = get_bits_count(&gbc);
+            len = unit->data_size;
+
+            slice->data_size = len - pos / 8;
+            slice->data_ref  = av_buffer_ref(unit->data_ref);
+            if (!slice->data_ref)
+                return AVERROR(ENOMEM);
+            slice->data = unit->data + pos / 8;
+            slice->data_bit_start = pos % 8;
+        }
+        break;
+
+    case VVC_AUD_NUT:
+        {
+            err = cbs_h266_read_aud(ctx, &gbc, unit->content);
+            if (err < 0)
+                return err;
+        }
+        break;
+
+    case VVC_PREFIX_SEI_NUT:
+    case VVC_SUFFIX_SEI_NUT:
+        {
+            err = cbs_h266_read_sei(ctx, &gbc, unit->content,
+                                    unit->type == VVC_PREFIX_SEI_NUT);
+
+            if (err < 0)
+                return err;
+        }
+        break;
+
+    default:
+        return AVERROR(ENOSYS);
+    }
+    return 0;
+}
+
 static int cbs_h2645_write_slice_data(CodedBitstreamContext *ctx,
                                       PutBitContext *pbc, const uint8_t *data,
                                       size_t data_size, int data_bit_start)
@@ -1007,7 +1257,7 @@ static int cbs_h264_write_nal_unit(CodedBitstreamContext *ctx,
             if (err < 0)
                 return err;
 
-            err = cbs_h264_replace_sps(ctx, unit);
+            err = cbs_h2645_replace_ps(ctx, unit);
             if (err < 0)
                 return err;
         }
@@ -1031,7 +1281,7 @@ static int cbs_h264_write_nal_unit(CodedBitstreamContext *ctx,
             if (err < 0)
                 return err;
 
-            err = cbs_h264_replace_pps(ctx, unit);
+            err = cbs_h2645_replace_ps(ctx, unit);
             if (err < 0)
                 return err;
         }
@@ -1124,7 +1374,7 @@ static int cbs_h265_write_nal_unit(CodedBitstreamContext *ctx,
             if (err < 0)
                 return err;
 
-            err = cbs_h265_replace_vps(ctx, unit);
+            err = cbs_h2645_replace_ps(ctx, unit);
             if (err < 0)
                 return err;
         }
@@ -1138,7 +1388,7 @@ static int cbs_h265_write_nal_unit(CodedBitstreamContext *ctx,
             if (err < 0)
                 return err;
 
-            err = cbs_h265_replace_sps(ctx, unit);
+            err = cbs_h2645_replace_ps(ctx, unit);
             if (err < 0)
                 return err;
         }
@@ -1152,7 +1402,7 @@ static int cbs_h265_write_nal_unit(CodedBitstreamContext *ctx,
             if (err < 0)
                 return err;
 
-            err = cbs_h265_replace_pps(ctx, unit);
+            err = cbs_h2645_replace_ps(ctx, unit);
             if (err < 0)
                 return err;
         }
@@ -1221,11 +1471,127 @@ static int cbs_h265_write_nal_unit(CodedBitstreamContext *ctx,
     return 0;
 }
 
+static int cbs_h266_write_nal_unit(CodedBitstreamContext *ctx,
+                                   CodedBitstreamUnit *unit,
+                                   PutBitContext *pbc)
+{
+    int err;
+
+    switch (unit->type) {
+    case VVC_VPS_NUT:
+        {
+            H266RawVPS *vps = unit->content;
+
+            err = cbs_h266_write_vps(ctx, pbc, vps);
+            if (err < 0)
+                return err;
+
+            err = cbs_h2645_replace_ps(ctx, unit);
+            if (err < 0)
+                return err;
+        }
+        break;
+    case VVC_SPS_NUT:
+        {
+            H266RawSPS *sps = unit->content;
+
+            err = cbs_h266_write_sps(ctx, pbc, sps);
+            if (err < 0)
+                return err;
+
+            err = cbs_h2645_replace_ps(ctx, unit);
+            if (err < 0)
+                return err;
+        }
+        break;
+
+    case VVC_PPS_NUT:
+        {
+            H266RawPPS *pps = unit->content;
+
+            err = cbs_h266_write_pps(ctx, pbc, pps);
+            if (err < 0)
+                return err;
+
+            err = cbs_h2645_replace_ps(ctx, unit);
+            if (err < 0)
+                return err;
+        }
+        break;
+
+    case VVC_PH_NUT:
+        {
+            H266RawPH *ph = unit->content;
+            err = cbs_h266_write_ph(ctx, pbc, ph);
+            if (err < 0)
+                return err;
+
+            err = cbs_h266_replace_ph(ctx, unit);
+            if (err < 0)
+                return err;
+        }
+        break;
+
+    case VVC_TRAIL_NUT:
+    case VVC_STSA_NUT:
+    case VVC_RADL_NUT:
+    case VVC_RASL_NUT:
+    case VVC_IDR_W_RADL:
+    case VVC_IDR_N_LP:
+    case VVC_CRA_NUT:
+    case VVC_GDR_NUT:
+        {
+            H266RawSlice *slice = unit->content;
+
+            err = cbs_h266_write_slice_header(ctx, pbc, &slice->header);
+            if (err < 0)
+                return err;
+
+            if (slice->data) {
+                err = cbs_h2645_write_slice_data(ctx, pbc, slice->data,
+                                                 slice->data_size,
+                                                 slice->data_bit_start);
+                if (err < 0)
+                    return err;
+            } else {
+                // No slice data - that was just the header.
+            }
+        }
+        break;
+
+    case VVC_AUD_NUT:
+        {
+            err = cbs_h266_write_aud(ctx, pbc, unit->content);
+            if (err < 0)
+                return err;
+        }
+        break;
+
+    case VVC_PREFIX_SEI_NUT:
+    case VVC_SUFFIX_SEI_NUT:
+        {
+            err = cbs_h266_write_sei(ctx, pbc, unit->content,
+                                     unit->type == VVC_PREFIX_SEI_NUT);
+
+            if (err < 0)
+                return err;
+        }
+        break;
+
+    default:
+        av_log(ctx->log_ctx, AV_LOG_ERROR, "Write unimplemented for "
+               "NAL unit type %"PRIu32".\n", unit->type);
+        return AVERROR_PATCHWELCOME;
+    }
+
+    return 0;
+}
+
 static int cbs_h2645_unit_requires_zero_byte(enum AVCodecID codec_id,
                                              CodedBitstreamUnitType type,
                                              int nal_unit_index)
 {
-    // Section B.1.2 in H.264, section B.2.2 in H.265.
+    // Section B.1.2 in H.264, section B.2.2 in H.265, H.266.
     if (nal_unit_index == 0) {
         // Assume that this is the first NAL unit in an access unit.
         return 1;
@@ -1234,6 +1600,8 @@ static int cbs_h2645_unit_requires_zero_byte(enum AVCodecID codec_id,
         return type == H264_NAL_SPS || type == H264_NAL_PPS;
     if (codec_id == AV_CODEC_ID_HEVC)
         return type == HEVC_NAL_VPS || type == HEVC_NAL_SPS || type == HEVC_NAL_PPS;
+    if (codec_id == AV_CODEC_ID_VVC)
+        return type >= VVC_OPI_NUT && type <= VVC_SUFFIX_APS_NUT;
     return 0;
 }
 
@@ -1385,6 +1753,37 @@ static void cbs_h265_close(CodedBitstreamContext *ctx)
         av_buffer_unref(&h265->pps_ref[i]);
 }
 
+static void cbs_h266_flush(CodedBitstreamContext *ctx)
+{
+    CodedBitstreamH266Context *h266 = ctx->priv_data;
+
+    for (int i = 0; i < FF_ARRAY_ELEMS(h266->vps); i++) {
+        av_buffer_unref(&h266->vps_ref[i]);
+        h266->vps[i] = NULL;
+    }
+
+    for (int i = 0; i < FF_ARRAY_ELEMS(h266->sps); i++) {
+        av_buffer_unref(&h266->sps_ref[i]);
+        h266->sps[i] = NULL;
+    }
+    for (int i = 0; i < FF_ARRAY_ELEMS(h266->pps); i++) {
+        av_buffer_unref(&h266->pps_ref[i]);
+        h266->pps[i] = NULL;
+    }
+    av_buffer_unref(&h266->priv.ph_ref);
+    h266->priv.ph = NULL;
+}
+
+
+static void cbs_h266_close(CodedBitstreamContext *ctx)
+{
+    CodedBitstreamH266Context *h266 = ctx->priv_data;
+
+    cbs_h266_flush(ctx);
+    ff_h2645_packet_uninit(&h266->common.read_packet);
+
+ }
+
 static void cbs_h264_free_sei(void *opaque, uint8_t *content)
 {
     H264RawSEI *sei = (H264RawSEI*)content;
@@ -1473,6 +1872,67 @@ static const CodedBitstreamUnitTypeDescriptor cbs_h265_unit_types[] = {
     CBS_UNIT_TYPE_END_OF_LIST
 };
 
+static void cbs_h266_free_sei(void *opaque, uint8_t *content)
+{
+    H265RawSEI *sei = (H265RawSEI*)content;
+    ff_cbs_sei_free_message_list(&sei->message_list);
+    av_free(content);
+}
+
+static const CodedBitstreamUnitTypeDescriptor cbs_h266_unit_types[] = {
+    CBS_UNIT_TYPE_INTERNAL_REF(VVC_VPS_NUT, H266RawVPS, extension_data.data),
+    CBS_UNIT_TYPE_INTERNAL_REF(VVC_PPS_NUT, H266RawPPS, extension_data.data),
+
+    CBS_UNIT_TYPE_POD(VVC_PH_NUT, H266RawPH),
+    CBS_UNIT_TYPE_POD(VVC_AUD_NUT, H266RawAUD),
+
+    {
+        .nb_unit_types = 1,
+        .unit_types = {
+            VVC_SPS_NUT
+        },
+        .content_type   = CBS_CONTENT_TYPE_INTERNAL_REFS,
+        .content_size   = sizeof(H266RawSPS),
+        .nb_ref_offsets = 2,
+        .ref_offsets    = {
+            offsetof(H266RawSPS, extension_data.data),
+            offsetof(H266RawSPS, vui.extension_data.data),
+        },
+    },
+
+    {
+        .nb_unit_types = 8,
+        .unit_types = {
+            VVC_TRAIL_NUT,
+            VVC_STSA_NUT,
+            VVC_RADL_NUT,
+            VVC_RASL_NUT,
+            VVC_IDR_W_RADL,
+            VVC_IDR_N_LP,
+            VVC_CRA_NUT,
+            VVC_GDR_NUT
+        },
+
+        .content_type   = CBS_CONTENT_TYPE_INTERNAL_REFS,
+        .content_size   = sizeof(H266RawSlice),
+        .nb_ref_offsets = 1,
+        .ref_offsets    = { offsetof(H266RawSlice, data) },
+    },
+
+    {
+        .nb_unit_types  = 2,
+        .unit_types     = {
+            VVC_PREFIX_SEI_NUT,
+            VVC_SUFFIX_SEI_NUT
+        },
+        .content_type   = CBS_CONTENT_TYPE_COMPLEX,
+        .content_size   = sizeof(H266RawSEI),
+        .content_free   = &cbs_h266_free_sei,
+    },
+
+    CBS_UNIT_TYPE_END_OF_LIST
+};
+
 const CodedBitstreamType ff_cbs_type_h264 = {
     .codec_id          = AV_CODEC_ID_H264,
 
@@ -1505,6 +1965,22 @@ const CodedBitstreamType ff_cbs_type_h265 = {
     .close             = &cbs_h265_close,
 };
 
+const CodedBitstreamType ff_cbs_type_h266 = {
+    .codec_id          = AV_CODEC_ID_VVC,
+
+    .priv_data_size    = sizeof(CodedBitstreamH266Context),
+
+    .unit_types        = cbs_h266_unit_types,
+
+    .split_fragment    = &cbs_h2645_split_fragment,
+    .read_unit         = &cbs_h266_read_nal_unit,
+    .write_unit        = &cbs_h266_write_nal_unit,
+    .assemble_fragment = &cbs_h2645_assemble_fragment,
+
+    .flush             = &cbs_h266_flush,
+    .close             = &cbs_h266_close,
+};
+
 static const SEIMessageTypeDescriptor cbs_sei_common_types[] = {
     {
         SEI_TYPE_FILLER_PAYLOAD,
@@ -1637,6 +2113,16 @@ static const SEIMessageTypeDescriptor cbs_sei_h265_types[] = {
     SEI_MESSAGE_TYPE_END
 };
 
+static const SEIMessageTypeDescriptor cbs_sei_h266_types[] = {
+    {
+        SEI_TYPE_DECODED_PICTURE_HASH,
+        0, 1,
+        sizeof(H266RawSEIDecodedPictureHash),
+        SEI_MESSAGE_RW(h266, sei_decoded_picture_hash),
+    },
+    SEI_MESSAGE_TYPE_END
+};
+
 const SEIMessageTypeDescriptor *ff_cbs_sei_find_type(CodedBitstreamContext *ctx,
                                                      int payload_type)
 {
@@ -1655,6 +2141,9 @@ const SEIMessageTypeDescriptor *ff_cbs_sei_find_type(CodedBitstreamContext *ctx,
     case AV_CODEC_ID_H265:
         codec_list = cbs_sei_h265_types;
         break;
+    case AV_CODEC_ID_H266:
+        codec_list = cbs_sei_h266_types;
+        break;
     default:
         return NULL;
     }
diff --git a/libavcodec/cbs_internal.h b/libavcodec/cbs_internal.h
index a392880..41bf998 100644
--- a/libavcodec/cbs_internal.h
+++ b/libavcodec/cbs_internal.h
@@ -40,7 +40,7 @@ enum CBSContentType {
 enum {
       // Maximum number of unit types described by the same unit type
       // descriptor.
-      CBS_MAX_UNIT_TYPES  = 3,
+      CBS_MAX_UNIT_TYPES  = 8,
       // Maximum number of reference buffer offsets in any one unit.
       CBS_MAX_REF_OFFSETS = 2,
       // Special value used in a unit type descriptor to indicate that it
@@ -204,6 +204,7 @@ int ff_cbs_write_signed(CodedBitstreamContext *ctx, PutBitContext *pbc,
 extern const CodedBitstreamType ff_cbs_type_av1;
 extern const CodedBitstreamType ff_cbs_type_h264;
 extern const CodedBitstreamType ff_cbs_type_h265;
+extern const CodedBitstreamType ff_cbs_type_h266;
 extern const CodedBitstreamType ff_cbs_type_jpeg;
 extern const CodedBitstreamType ff_cbs_type_mpeg2;
 extern const CodedBitstreamType ff_cbs_type_vp9;
diff --git a/libavcodec/cbs_sei.c b/libavcodec/cbs_sei.c
index 141e97e..ce47ba3 100644
--- a/libavcodec/cbs_sei.c
+++ b/libavcodec/cbs_sei.c
@@ -20,6 +20,7 @@
 #include "cbs_internal.h"
 #include "cbs_h264.h"
 #include "cbs_h265.h"
+#include "cbs_h266.h"
 #include "cbs_sei.h"
 
 static void cbs_free_user_data_registered(void *opaque, uint8_t *data)
@@ -132,6 +133,13 @@ static int cbs_sei_get_unit(CodedBitstreamContext *ctx,
         else
             sei_type = HEVC_NAL_SEI_SUFFIX;
         break;
+    case AV_CODEC_ID_H266:
+        highest_vcl_type = VVC_RSV_IRAP_11;
+        if (prefix)
+            sei_type = VVC_PREFIX_SEI_NUT;
+        else
+            sei_type = VVC_SUFFIX_SEI_NUT;
+        break;
     default:
         return AVERROR(EINVAL);
     }
@@ -207,6 +215,18 @@ static int cbs_sei_get_unit(CodedBitstreamContext *ctx,
             memcpy(unit->content, &sei, sizeof(sei));
         }
         break;
+    case AV_CODEC_ID_H266:
+        {
+            H266RawSEI sei = {
+                .nal_unit_header = {
+                    .nal_unit_type         = sei_type,
+                    .nuh_layer_id          = 0,
+                    .nuh_temporal_id_plus1 = 1,
+                },
+            };
+            memcpy(unit->content, &sei, sizeof(sei));
+        }
+        break;
     default:
         av_assert0(0);
     }
@@ -237,6 +257,15 @@ static int cbs_sei_get_message_list(CodedBitstreamContext *ctx,
             *list = &sei->message_list;
         }
         break;
+    case AV_CODEC_ID_H266:
+        {
+            H266RawSEI *sei = unit->content;
+            if (unit->type != VVC_PREFIX_SEI_NUT &&
+                unit->type != VVC_SUFFIX_SEI_NUT)
+                return AVERROR(EINVAL);
+            *list = &sei->message_list;
+        }
+        break;
     default:
         return AVERROR(EINVAL);
     }
diff --git a/libavcodec/h2645_parse.c b/libavcodec/h2645_parse.c
index 6fbe97a..fb18343 100644
--- a/libavcodec/h2645_parse.c
+++ b/libavcodec/h2645_parse.c
@@ -1,5 +1,5 @@
 /*
- * H.264/HEVC common parsing code
+ * H.264/HEVC/VVC common parsing code
  *
  * This file is part of FFmpeg.
  *
@@ -27,6 +27,7 @@
 #include "libavutil/mem.h"
 
 #include "bytestream.h"
+#include "vvc.h"
 #include "hevc.h"
 #include "h264.h"
 #include "h2645_parse.h"
@@ -146,6 +147,47 @@ nsc:
     return si;
 }
 
+static const char *const vvc_nal_type_name[32] = {
+    "TRAIL_NUT", // VVC_TRAIL_NUT
+    "STSA_NUT", // VVC_STSA_NUT
+    "RADL_NUT", // VVC_RADL_NUT
+    "RASL_NUT", // VVC_RASL_NUT
+    "RSV_VCL_4", // VVC_RSV_VCL_4
+    "RSV_VCL_5", // VVC_RSV_VCL_5
+    "RSV_VCL_6", // VVC_RSV_VCL_6
+    "IDR_W_RADL", // VVC_IDR_W_RADL
+    "IDR_N_LP", // VVC_IDR_N_LP
+    "CRA_NUT", // VVC_CRA_NUT
+    "GDR_NUT", // VVC_GDR_NUT
+    "RSV_IRAP_11", // VVC_RSV_IRAP_11
+    "OPI_NUT", // VVC_OPI_NUT
+    "DCI_NUT", // VVC_DCI_NUT
+    "VPS_NUT", // VVC_VPS_NUT
+    "SPS_NUT", // VVC_SPS_NUT
+    "PPS_NUT", // VVC_PPS_NUT
+    "PREFIX_APS_NUT",// VVC_PREFIX_APS_NUT
+    "SUFFIX_APS_NUT",// VVC_SUFFIX_APS_NUT
+    "PH_NUT", // VVC_PH_NUT
+    "AUD_NUT", // VVC_AUD_NUT
+    "EOS_NUT", // VVC_EOS_NUT
+    "EOB_NUT", // VVC_EOB_NUT
+    "PREFIX_SEI_NUT",// VVC_PREFIX_SEI_NUT
+    "SUFFIX_SEI_NUT",// VVC_SUFFIX_SEI_NUT
+    "FD_NUT", // VVC_FD_NUT
+    "RSV_NVCL_26", // VVC_RSV_NVCL_26
+    "RSV_NVCL_27", // VVC_RSV_NVCL_27
+    "UNSPEC_28", // VVC_UNSPEC_28
+    "UNSPEC_29", // VVC_UNSPEC_29
+    "UNSPEC_30", // VVC_UNSPEC_30
+    "UNSPEC_31", // VVC_UNSPEC_31
+};
+
+static const char *vvc_nal_unit_name(int nal_type)
+{
+    av_assert0(nal_type >= 0 && nal_type < 32);
+    return vvc_nal_type_name[nal_type];
+}
+
 static const char *const hevc_nal_type_name[64] = {
     "TRAIL_N", // HEVC_NAL_TRAIL_N
     "TRAIL_R", // HEVC_NAL_TRAIL_R
@@ -289,6 +331,31 @@ static int get_bit_length(H2645NAL *nal, int skip_trailing_zeros)
  * @return AVERROR_INVALIDDATA if the packet is not a valid NAL unit,
  * 0 otherwise
  */
+static int vvc_parse_nal_header(H2645NAL *nal, void *logctx)
+{
+    GetBitContext *gb = &nal->gb;
+
+    if (get_bits1(gb) != 0)     //forbidden_zero_bit
+        return AVERROR_INVALIDDATA;
+
+    skip_bits1(gb);             //nuh_reserved_zero_bit
+
+    nal->nuh_layer_id = get_bits(gb, 6);
+    nal->type = get_bits(gb, 5);
+    nal->temporal_id = get_bits(gb, 3) - 1;
+    if (nal->temporal_id < 0)
+        return AVERROR_INVALIDDATA;
+
+    if ((nal->type >= VVC_IDR_W_RADL && nal->type <= VVC_RSV_IRAP_11) && nal->temporal_id)
+        return AVERROR_INVALIDDATA;
+
+    av_log(logctx, AV_LOG_DEBUG,
+      "nal_unit_type: %d(%s), nuh_layer_id: %d, temporal_id: %d\n",
+           nal->type, vvc_nal_unit_name(nal->type), nal->nuh_layer_id, nal->temporal_id);
+
+    return 0;
+}
+
 static int hevc_parse_nal_header(H2645NAL *nal, void *logctx)
 {
     GetBitContext *gb = &nal->gb;
@@ -504,7 +571,9 @@ int ff_h2645_packet_split(H2645Packet *pkt, const uint8_t *buf, int length,
         /* Reset type in case it contains a stale value from a previously parsed NAL */
         nal->type = 0;
 
-        if (codec_id == AV_CODEC_ID_HEVC)
+        if (codec_id == AV_CODEC_ID_VVC)
+            ret = vvc_parse_nal_header(nal, logctx);
+        else if (codec_id == AV_CODEC_ID_HEVC)
             ret = hevc_parse_nal_header(nal, logctx);
         else
             ret = h264_parse_nal_header(nal, logctx);
diff --git a/libavcodec/parsers.c b/libavcodec/parsers.c
index 3d944f5..f76d1d9 100644
--- a/libavcodec/parsers.c
+++ b/libavcodec/parsers.c
@@ -72,6 +72,7 @@ extern AVCodecParser ff_vorbis_parser;
 extern AVCodecParser ff_vp3_parser;
 extern AVCodecParser ff_vp8_parser;
 extern AVCodecParser ff_vp9_parser;
+extern AVCodecParser ff_vp9_parser;
 extern AVCodecParser ff_webp_parser;
 extern AVCodecParser ff_xbm_parser;
 extern AVCodecParser ff_xma_parser;
diff --git a/libavformat/Makefile b/libavformat/Makefile
index 0f340f7..b706be4 100644
--- a/libavformat/Makefile
+++ b/libavformat/Makefile
@@ -311,7 +311,7 @@ OBJS-$(CONFIG_MATROSKA_DEMUXER)          += matroskadec.o matroska.o  \
                                             oggparsevorbis.o vorbiscomment.o \
                                             qtpalette.o replaygain.o
 OBJS-$(CONFIG_MATROSKA_MUXER)            += matroskaenc.o matroska.o \
-                                            av1.o avc.o hevc.o isom_tags.o \
+                                            av1.o avc.o hevc.o vvc.o isom_tags.o \
                                             flacenc_header.o avlanguage.o \
                                             vorbiscomment.o wv.o
 OBJS-$(CONFIG_MCA_DEMUXER)               += mca.o
@@ -333,7 +333,7 @@ OBJS-$(CONFIG_MODS_DEMUXER)              += mods.o
 OBJS-$(CONFIG_MOFLEX_DEMUXER)            += moflex.o
 OBJS-$(CONFIG_MOV_DEMUXER)               += mov.o mov_chan.o mov_esds.o \
                                             qtpalette.o replaygain.o
-OBJS-$(CONFIG_MOV_MUXER)                 += movenc.o av1.o avc.o hevc.o vpcc.o \
+OBJS-$(CONFIG_MOV_MUXER)                 += movenc.o av1.o avc.o hevc.o vvc.o vpcc.o \
                                             movenchint.o mov_chan.o rtp.o \
                                             movenccenc.o rawutils.o
 OBJS-$(CONFIG_MP2_MUXER)                 += rawenc.o
@@ -480,7 +480,7 @@ OBJS-$(CONFIG_RTP_MUXER)                 += rtp.o         \
                                             rtpenc_vp8.o  \
                                             rtpenc_vp9.o                \
                                             rtpenc_xiph.o \
-                                            avc.o hevc.o
+                                            avc.o hevc.o vvc.o
 OBJS-$(CONFIG_RTSP_DEMUXER)              += rtsp.o rtspdec.o httpauth.o \
                                             urldecode.o
 OBJS-$(CONFIG_RTSP_MUXER)                += rtsp.o rtspenc.o httpauth.o \
@@ -567,13 +567,15 @@ OBJS-$(CONFIG_VOC_MUXER)                 += vocenc.o voc.o
 OBJS-$(CONFIG_VPK_DEMUXER)               += vpk.o
 OBJS-$(CONFIG_VPLAYER_DEMUXER)           += vplayerdec.o subtitles.o
 OBJS-$(CONFIG_VQF_DEMUXER)               += vqf.o
+OBJS-$(CONFIG_VVC_DEMUXER)               += vvcdec.o rawdec.o
+OBJS-$(CONFIG_VVC_MUXER)                 += rawenc.o
 OBJS-$(CONFIG_W64_DEMUXER)               += wavdec.o w64.o pcm.o
 OBJS-$(CONFIG_W64_MUXER)                 += wavenc.o w64.o
 OBJS-$(CONFIG_WAV_DEMUXER)               += wavdec.o pcm.o
 OBJS-$(CONFIG_WAV_MUXER)                 += wavenc.o
 OBJS-$(CONFIG_WC3_DEMUXER)               += wc3movie.o
 OBJS-$(CONFIG_WEBM_MUXER)                += matroskaenc.o matroska.o \
-                                            av1.o avc.o hevc.o isom_tags.o \
+                                            av1.o avc.o hevc.o vvc.o isom_tags.o \
                                             flacenc_header.o avlanguage.o \
                                             wv.o vorbiscomment.o
 OBJS-$(CONFIG_WEBM_DASH_MANIFEST_MUXER)  += webmdashenc.o
diff --git a/libavformat/allformats.c b/libavformat/allformats.c
index a38fd1f..00b7c60 100644
--- a/libavformat/allformats.c
+++ b/libavformat/allformats.c
@@ -466,6 +466,8 @@ extern AVOutputFormat ff_voc_muxer;
 extern AVInputFormat  ff_vpk_demuxer;
 extern AVInputFormat  ff_vplayer_demuxer;
 extern AVInputFormat  ff_vqf_demuxer;
+extern AVInputFormat  ff_vvc_demuxer;
+extern AVOutputFormat ff_vvc_muxer;
 extern AVInputFormat  ff_w64_demuxer;
 extern AVOutputFormat ff_w64_muxer;
 extern AVInputFormat  ff_wav_demuxer;
diff --git a/libavformat/avio_internal.h b/libavformat/avio_internal.h
index fe87f2a..51fad00 100644
--- a/libavformat/avio_internal.h
+++ b/libavformat/avio_internal.h
@@ -60,6 +60,11 @@ static av_always_inline void ffio_wfourcc(AVIOContext *pb, const uint8_t *s)
     avio_wl32(pb, MKTAG(s[0], s[1], s[2], s[3]));
 }
 
+static av_always_inline void ffio_wfourcc_full_box(AVIOContext *pb, const uint8_t *s)
+{
+    avio_wl64(pb, MKTAG(s[0], s[1], s[2], s[3]));
+}
+
 /**
  * Rewind the AVIOContext using the specified buffer containing the first buf_size bytes of the file.
  * Used after probing to avoid seeking.
diff --git a/libavformat/dashdec.c b/libavformat/dashdec.c
index 6f3f28d..b154006 100644
--- a/libavformat/dashdec.c
+++ b/libavformat/dashdec.c
@@ -1796,7 +1796,16 @@ restart:
                 goto end;
             }
             av_log(v->parent, AV_LOG_WARNING, "Failed to open fragment of playlist\n");
-            v->cur_seq_no++;
+            
+
+            if (!c->is_live) {
+                v->cur_seq_no++;
+            } else {
+            	int max_seq_no = calc_max_seg_no(v, c);
+            	if (max_seq_no > v->cur_seq_no)
+            		v->cur_seq_no++;
+            }
+
             goto restart;
         }
     }
@@ -1822,10 +1831,18 @@ restart:
     if (ret > 0)
         goto end;
 
-    if (c->is_live || v->cur_seq_no < v->last_seq_no) {
+    if (v->cur_seq_no < v->last_seq_no) {
         if (!v->is_restart_needed)
             v->cur_seq_no++;
         v->is_restart_needed = 1;
+    } else if (c->is_live) {
+        if (!v->is_restart_needed) {
+        	while (v->cur_seq_no == calc_max_seg_no(v, c)) {
+        		av_usleep(50000); 
+        	}
+                v->cur_seq_no++;
+        }
+        v->is_restart_needed = 1;
     }
 
 end:
diff --git a/libavformat/isom.c b/libavformat/isom.c
index df98779..be9ed3c 100644
--- a/libavformat/isom.c
+++ b/libavformat/isom.c
@@ -36,6 +36,7 @@ const AVCodecTag ff_mp4_obj_type[] = {
     { AV_CODEC_ID_MPEG4       , 0x20 },
     { AV_CODEC_ID_H264        , 0x21 },
     { AV_CODEC_ID_HEVC        , 0x23 },
+    { AV_CODEC_ID_VVC         , 0x33 },
     { AV_CODEC_ID_AAC         , 0x40 },
     { AV_CODEC_ID_MP4ALS      , 0x40 }, /* 14496-3 ALS */
     { AV_CODEC_ID_MPEG2VIDEO  , 0x61 }, /* MPEG-2 Main */
diff --git a/libavformat/isom_tags.c b/libavformat/isom_tags.c
index 1666b9d..fac10c5 100644
--- a/libavformat/isom_tags.c
+++ b/libavformat/isom_tags.c
@@ -120,6 +120,8 @@ const AVCodecTag ff_codec_movvideo_tags[] = {
     { AV_CODEC_ID_HEVC, MKTAG('h', 'v', 'c', '1') }, /* HEVC/H.265 which indicates parameter sets shall not be in ES */
     { AV_CODEC_ID_HEVC, MKTAG('d', 'v', 'h', 'e') }, /* HEVC-based Dolby Vision derived from hev1 */
                                                      /* dvh1 is handled within mov.c */
+    { AV_CODEC_ID_VVC, MKTAG('v', 'v', 'i', '1') },  /* VVC/H.266 which indicates parameter sets may be in ES */
+    { AV_CODEC_ID_VVC, MKTAG('v', 'v', 'c', '1') },  /* VVC/H.266 which indicates parameter shall not be in ES */
 
     { AV_CODEC_ID_H264, MKTAG('a', 'v', 'c', '1') }, /* AVC-1/H.264 */
     { AV_CODEC_ID_H264, MKTAG('a', 'v', 'c', '2') },
diff --git a/libavformat/mov.c b/libavformat/mov.c
index 46d8e62..5bea62c 100644
--- a/libavformat/mov.c
+++ b/libavformat/mov.c
@@ -1939,6 +1939,11 @@ static int mov_read_glbl(MOVContext *c, AVIOContext *pb, MOVAtom atom)
     if ((uint64_t)atom.size > (1<<30))
         return AVERROR_INVALIDDATA;
 
+    if (atom.type == MKTAG('v','v','c','C')) {
+        avio_rb32(pb);
+        atom.size -= 4;
+    }
+
     if (atom.size >= 10) {
         // Broken files created by legacy versions of libavformat will
         // wrap a whole fiel atom inside of a glbl atom.
@@ -6996,6 +7001,7 @@ static const MOVParseTableEntry mov_default_parse_table[] = {
 { MKTAG('d','v','c','1'), mov_read_dvc1 },
 { MKTAG('s','b','g','p'), mov_read_sbgp },
 { MKTAG('h','v','c','C'), mov_read_glbl },
+{ MKTAG('v','v','c','C'), mov_read_glbl },
 { MKTAG('u','u','i','d'), mov_read_uuid },
 { MKTAG('C','i','n', 0x8e), mov_read_targa_y216 },
 { MKTAG('f','r','e','e'), mov_read_free },
diff --git a/libavformat/movenc.c b/libavformat/movenc.c
index 8a06de2..641b4c9 100644
--- a/libavformat/movenc.c
+++ b/libavformat/movenc.c
@@ -54,6 +54,7 @@
 #include "libavutil/dovi_meta.h"
 #include "libavutil/color_utils.h"
 #include "hevc.h"
+#include "vvc.h"
 #include "rtpenc.h"
 #include "mov_chan.h"
 #include "vpcc.h"
@@ -1337,6 +1338,20 @@ static int mov_write_hvcc_tag(AVIOContext *pb, MOVTrack *track)
     return update_size(pb, pos);
 }
 
+static int mov_write_vvcc_tag(AVIOContext *pb, MOVTrack *track)
+{
+    int64_t pos = avio_tell(pb);
+
+    avio_wb32(pb, 0);
+    ffio_wfourcc_full_box(pb, "vvcC");
+    //avio_wb32(pb, 0);
+    if (track->tag == MKTAG('v','v','i','1'))
+        ff_isom_write_vvcc(pb, track->vos_data, track->vos_len, 1);
+    else
+        ff_isom_write_vvcc(pb, track->vos_data, track->vos_len, 0);
+    return update_size(pb, pos);
+}
+
 /* also used by all avid codecs (dv, imx, meridien) and their variants */
 static int mov_write_avid_tag(AVIOContext *pb, MOVTrack *track)
 {
@@ -2211,6 +2226,8 @@ static int mov_write_video_tag(AVFormatContext *s, AVIOContext *pb, MOVMuxContex
         avid = 1;
     } else if (track->par->codec_id == AV_CODEC_ID_HEVC)
         mov_write_hvcc_tag(pb, track);
+    else if (track->par->codec_id == AV_CODEC_ID_VVC)
+        mov_write_vvcc_tag(pb, track);
     else if (track->par->codec_id == AV_CODEC_ID_H264 && !TAG_IS_AVCI(track->tag)) {
         mov_write_avcc_tag(pb, track);
         if (track->mode == MODE_IPOD)
@@ -5649,6 +5666,7 @@ int ff_mov_write_packet(AVFormatContext *s, AVPacket *pkt)
     if ((par->codec_id == AV_CODEC_ID_DNXHD ||
          par->codec_id == AV_CODEC_ID_H264 ||
          par->codec_id == AV_CODEC_ID_HEVC ||
+         par->codec_id == AV_CODEC_ID_VVC ||
          par->codec_id == AV_CODEC_ID_TRUEHD ||
          par->codec_id == AV_CODEC_ID_AC3) && !trk->vos_len &&
          !TAG_IS_AVCI(trk->tag)) {
@@ -5705,6 +5723,18 @@ int ff_mov_write_packet(AVFormatContext *s, AVPacket *pkt)
         } else {
             size = ff_hevc_annexb2mp4(pb, pkt->data, pkt->size, 0, NULL);
         }
+    } else if (par->codec_id == AV_CODEC_ID_VVC && trk->vos_len > 6 &&
+               (AV_RB24(trk->vos_data) == 1 || AV_RB32(trk->vos_data) == 1)) {
+      /* extradata is Annex B, assume the bitstream is too and convert it */
+      if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) {
+            ret = ff_vvc_annexb2mp4_buf(pkt->data, &reformatted_data,
+                                         &size, 0, NULL);
+            if (ret < 0)
+                return ret;
+            avio_write(pb, reformatted_data, size);
+      } else {
+          size = ff_vvc_annexb2mp4(pb, pkt->data, pkt->size, 0, NULL);
+      }
     } else if (par->codec_id == AV_CODEC_ID_AV1) {
         if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) {
             ret = ff_av1_filter_obus_buf(pkt->data, &reformatted_data,
@@ -6836,19 +6866,6 @@ static int mov_write_header(AVFormatContext *s)
             avio_skip(pb, mov->reserved_moov_size);
     }
 
-    if (mov->flags & FF_MOV_FLAG_FRAGMENT) {
-        /* If no fragmentation options have been set, set a default. */
-        if (!(mov->flags & (FF_MOV_FLAG_FRAG_KEYFRAME |
-                            FF_MOV_FLAG_FRAG_CUSTOM |
-                            FF_MOV_FLAG_FRAG_EVERY_FRAME)) &&
-            !mov->max_fragment_duration && !mov->max_fragment_size)
-            mov->flags |= FF_MOV_FLAG_FRAG_KEYFRAME;
-    } else {
-        if (mov->flags & FF_MOV_FLAG_FASTSTART)
-            mov->reserved_header_pos = avio_tell(pb);
-        mov_write_mdat_tag(pb, mov);
-    }
-
     ff_parse_creation_time_metadata(s, &mov->time, 1);
     if (mov->time)
         mov->time += 0x7C25B080; // 1970 based -> 1904 based
@@ -6904,6 +6921,19 @@ static int mov_write_header(AVFormatContext *s)
             mov->reserved_header_pos = avio_tell(pb);
     }
 
+    if (mov->flags & FF_MOV_FLAG_FRAGMENT) {
+        /* If no fragmentation options have been set, set a default. */
+        if (!(mov->flags & (FF_MOV_FLAG_FRAG_KEYFRAME |
+                            FF_MOV_FLAG_FRAG_CUSTOM |
+                            FF_MOV_FLAG_FRAG_EVERY_FRAME)) &
+            !mov->max_fragment_duration && !mov->max_fragment_size)
+            mov->flags |= FF_MOV_FLAG_FRAG_KEYFRAME;
+    } else {
+        if (mov->flags & FF_MOV_FLAG_FASTSTART)
+            mov->reserved_header_pos = avio_tell(pb);
+        mov_write_mdat_tag(pb, mov);
+    }
+
     return 0;
 }
 
@@ -7197,6 +7227,8 @@ static const AVCodecTag codec_mp4_tags[] = {
     { AV_CODEC_ID_H264,            MKTAG('a', 'v', 'c', '3') },
     { AV_CODEC_ID_HEVC,            MKTAG('h', 'e', 'v', '1') },
     { AV_CODEC_ID_HEVC,            MKTAG('h', 'v', 'c', '1') },
+    { AV_CODEC_ID_VVC,             MKTAG('v', 'v', 'c', '1') },
+    { AV_CODEC_ID_VVC,             MKTAG('v', 'v', 'i', '1') },
     { AV_CODEC_ID_MPEG2VIDEO,      MKTAG('m', 'p', '4', 'v') },
     { AV_CODEC_ID_MPEG1VIDEO,      MKTAG('m', 'p', '4', 'v') },
     { AV_CODEC_ID_MJPEG,           MKTAG('m', 'p', '4', 'v') },
diff --git a/libavformat/mpegts.c b/libavformat/mpegts.c
index a303313..032da59 100644
--- a/libavformat/mpegts.c
+++ b/libavformat/mpegts.c
@@ -803,7 +803,8 @@ static const StreamType ISO_types[] = {
     { 0x1c, AVMEDIA_TYPE_AUDIO, AV_CODEC_ID_AAC        },
     { 0x20, AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_H264       },
     { 0x21, AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_JPEG2000   },
-    { 0x24, AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_HEVC       },
+    
+    { 0x33, AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_VVC        },
     { 0x42, AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_CAVS       },
     { 0xd1, AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_DIRAC      },
     { 0xd2, AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_AVS2       },
@@ -848,6 +849,7 @@ static const StreamType REGD_types[] = {
     { MKTAG('D', 'T', 'S', '3'), AVMEDIA_TYPE_AUDIO, AV_CODEC_ID_DTS   },
     { MKTAG('E', 'A', 'C', '3'), AVMEDIA_TYPE_AUDIO, AV_CODEC_ID_EAC3  },
     { MKTAG('H', 'E', 'V', 'C'), AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_HEVC  },
+    { MKTAG('V', 'V', 'C', ' '), AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_VVC   },
     { MKTAG('K', 'L', 'V', 'A'), AVMEDIA_TYPE_DATA,  AV_CODEC_ID_SMPTE_KLV },
     { MKTAG('I', 'D', '3', ' '), AVMEDIA_TYPE_DATA,  AV_CODEC_ID_TIMED_ID3 },
     { MKTAG('V', 'C', '-', '1'), AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_VC1   },
diff --git a/libavformat/mpegts.h b/libavformat/mpegts.h
index 04874e0..4f12685 100644
--- a/libavformat/mpegts.h
+++ b/libavformat/mpegts.h
@@ -128,6 +128,7 @@
 #define STREAM_TYPE_METADATA        0x15
 #define STREAM_TYPE_VIDEO_H264      0x1b
 #define STREAM_TYPE_VIDEO_HEVC      0x24
+#define STREAM_TYPE_VIDEO_VVC       0x33
 #define STREAM_TYPE_VIDEO_CAVS      0x42
 #define STREAM_TYPE_VIDEO_VC1       0xea
 #define STREAM_TYPE_VIDEO_DIRAC     0xd1
diff --git a/libavformat/mpegtsenc.c b/libavformat/mpegtsenc.c
index 35c835c..ad94e51 100644
--- a/libavformat/mpegtsenc.c
+++ b/libavformat/mpegtsenc.c
@@ -307,6 +307,9 @@ static int get_dvb_stream_type(AVFormatContext *s, AVStream *st)
     case AV_CODEC_ID_HEVC:
         stream_type = STREAM_TYPE_VIDEO_HEVC;
         break;
+    case AV_CODEC_ID_VVC:
+        stream_type = STREAM_TYPE_VIDEO_VVC;
+        break;
     case AV_CODEC_ID_CAVS:
         stream_type = STREAM_TYPE_VIDEO_CAVS;
         break;
@@ -383,7 +386,11 @@ static int get_m2ts_stream_type(AVFormatContext *s, AVStream *st)
     int stream_type;
     MpegTSWriteStream *ts_st = st->priv_data;
 
-    switch (st->codecpar->codec_id) {
+    av_log(s, AV_LOG_ERROR,
+                    "mra Stream %d, codec %s, is muxed as a private data stream.\n", st->index,
+                    avcodec_get_name(st->codecpar->codec_id));
+
+   switch (st->codecpar->codec_id) {
     case AV_CODEC_ID_MPEG2VIDEO:
         stream_type = STREAM_TYPE_VIDEO_MPEG2;
         break;
@@ -396,6 +403,11 @@ static int get_m2ts_stream_type(AVFormatContext *s, AVStream *st)
     case AV_CODEC_ID_HEVC:
         stream_type = STREAM_TYPE_VIDEO_HEVC;
         break;
+    case AV_CODEC_ID_VVC:
+         av_log(s, AV_LOG_ERROR,
+                    "MPEGTS VVC %s.\n", avcodec_get_name(st->codecpar->codec_id));
+        stream_type = STREAM_TYPE_VIDEO_VVC;
+        break;
     case AV_CODEC_ID_PCM_BLURAY:
         stream_type = 0x80;
         break;
@@ -1618,6 +1630,21 @@ static int check_hevc_startcode(AVFormatContext *s, const AVStream *st, const AV
     return 0;
 }
 
+static int check_vvc_startcode(AVFormatContext *s, const AVStream *st, const AVPacket *pkt)
+{
+    if (pkt->size < 5 || AV_RB32(pkt->data) != 0x0000001 && AV_RB24(pkt->data) != 0x000001) {
+        if (!st->nb_frames) {
+            av_log(s, AV_LOG_ERROR, "VVC bitstream malformed, no startcode found\n");
+            return AVERROR_PATCHWELCOME;
+        }
+        av_log(s, AV_LOG_WARNING, "VVC bitstream error, startcode missing, size %d", pkt->size);
+        if (pkt->size)
+            av_log(s, AV_LOG_WARNING, " data %08"PRIX32, AV_RB32(pkt->data));
+        av_log(s, AV_LOG_WARNING, "\n");
+    }
+    return 0;
+}
+
 /* Based on GStreamer's gst-plugins-base/ext/ogg/gstoggstream.c
  * Released under the LGPL v2.1+, written by
  * Vincent Penquerc'h <vincent.penquerch@collabora.co.uk>
@@ -1795,6 +1822,40 @@ static int mpegts_write_packet_internal(AVFormatContext *s, AVPacket *pkt)
         } while (p < buf_end && (state & 0x7e) != 2*35 &&
                  (state & 0x7e) >= 2*32);
 
+        if ((state & 0x7e) < 2*16 || (state & 0x7e) >= 2*24)
+            extradd = 0;
+        if ((state & 0x7e) != 2*35) { // AUD NAL
+            data = av_malloc(pkt->size + 7 + extradd);
+            if (!data)
+                return AVERROR(ENOMEM);
+            memcpy(data + 7, st->codecpar->extradata, extradd);
+            memcpy(data + 7 + extradd, pkt->data, pkt->size);
+            AV_WB32(data, 0x00000001);
+            data[4] = 2*35;
+            data[5] = 1;
+            data[6] = 0x50; // any slice type (0x4) + rbsp stop one bit
+            buf     = data;
+            size    = pkt->size + 7 + extradd;
+        }
+    } else if (st->codecpar->codec_id == AV_CODEC_ID_VVC) {
+        const uint8_t *p = buf, *buf_end = p + size;
+        uint32_t state = -1;
+        int extradd = (pkt->flags & AV_PKT_FLAG_KEY) ? st->codecpar->extradata_size : 0;
+        int ret = check_vvc_startcode(s, st, pkt);
+        if (ret < 0)
+            return ret;
+
+        if (extradd && AV_RB24(st->codecpar->extradata) > 1)
+            extradd = 0;
+
+        do {
+            p = avpriv_find_start_code(p, buf_end, &state);
+            av_log(s, AV_LOG_TRACE, "nal %"PRId32"\n", (state & 0x7e)>>1);
+            if ((state & 0x7e) == 2*32)
+                extradd = 0;
+        } while (p < buf_end && (state & 0x7e) != 2*35 &&
+                 (state & 0x7e) >= 2*32);
+
         if ((state & 0x7e) < 2*16 || (state & 0x7e) >= 2*24)
             extradd = 0;
         if ((state & 0x7e) != 2*35) { // AUD NAL
@@ -2064,6 +2125,12 @@ static int mpegts_check_bitstream(struct AVFormatContext *s, const AVPacket *pkt
                               (st->codecpar->extradata_size > 0 &&
                                st->codecpar->extradata[0] == 1)))
             ret = ff_stream_add_bitstream_filter(st, "hevc_mp4toannexb", NULL);
+    } else if (st->codecpar->codec_id == AV_CODEC_ID_VVC) {
+        if (pkt->size >= 5 && AV_RB32(pkt->data) != 0x0000001 &&
+                             (AV_RB24(pkt->data) != 0x000001 ||
+                              (st->codecpar->extradata_size > 0 &&
+                               st->codecpar->extradata[0] == 1)))
+            ret = ff_stream_add_bitstream_filter(st, "vvc_mp4toannexb", NULL);
     }
 
     return ret;
diff --git a/libavformat/rawenc.c b/libavformat/rawenc.c
index caec297..bda006c 100644
--- a/libavformat/rawenc.c
+++ b/libavformat/rawenc.c
@@ -372,6 +372,31 @@ AVOutputFormat ff_hevc_muxer = {
 };
 #endif
 
+#if CONFIG_VVC_MUXER
+static int vvc_check_bitstream(struct AVFormatContext *s, const AVPacket *pkt)
+{
+    if (pkt->size >= 5 && AV_RB32(pkt->data) != 0x0000001 &&
+                          AV_RB24(pkt->data) != 0x000001) {
+        //TODO: fixed this after vvc codec defined in http://mp4ra.org/#/codecs
+        av_log(s, AV_LOG_ERROR, "vvc: mp4 to annexb is not supported\n");
+        return AVERROR_PATCHWELCOME;
+    }
+    return 1;
+}
+
+AVOutputFormat ff_vvc_muxer = {
+    .name              = "vvc",
+    .long_name         = NULL_IF_CONFIG_SMALL("raw VVC video"),
+    .extensions        = "vvc,h266,266",
+    .audio_codec       = AV_CODEC_ID_NONE,
+    .video_codec       = AV_CODEC_ID_VVC,
+    .write_header      = force_one_stream,
+    .write_packet      = ff_raw_write_packet,
+    .check_bitstream   = vvc_check_bitstream,
+    .flags             = AVFMT_NOTIMESTAMPS,
+};
+#endif
+
 #if CONFIG_M4V_MUXER
 AVOutputFormat ff_m4v_muxer = {
     .name              = "m4v",
diff --git a/libavformat/utils.c b/libavformat/utils.c
index b2d011a..4c257a9 100644
--- a/libavformat/utils.c
+++ b/libavformat/utils.c
@@ -354,6 +354,7 @@ static int set_codec_from_probe_data(AVFormatContext *s, AVStream *st,
         { "eac3",      AV_CODEC_ID_EAC3,       AVMEDIA_TYPE_AUDIO },
         { "h264",      AV_CODEC_ID_H264,       AVMEDIA_TYPE_VIDEO },
         { "hevc",      AV_CODEC_ID_HEVC,       AVMEDIA_TYPE_VIDEO },
+        { "vvc",       AV_CODEC_ID_VVC,        AVMEDIA_TYPE_VIDEO },
         { "loas",      AV_CODEC_ID_AAC_LATM,   AVMEDIA_TYPE_AUDIO },
         { "m4v",       AV_CODEC_ID_MPEG4,      AVMEDIA_TYPE_VIDEO },
         { "mjpeg_2000",AV_CODEC_ID_JPEG2000,   AVMEDIA_TYPE_VIDEO },
@@ -1043,7 +1044,8 @@ static PacketList *get_next_pkt(AVFormatContext *s, AVStream *st, PacketList *pk
 
 static int64_t select_from_pts_buffer(AVStream *st, int64_t *pts_buffer, int64_t dts) {
     int onein_oneout = st->codecpar->codec_id != AV_CODEC_ID_H264 &&
-                       st->codecpar->codec_id != AV_CODEC_ID_HEVC;
+                       st->codecpar->codec_id != AV_CODEC_ID_HEVC &&
+                       st->codecpar->codec_id != AV_CODEC_ID_VVC;
 
     if(!onein_oneout) {
         int delay = st->internal->avctx->has_b_frames;
@@ -1231,7 +1233,8 @@ static void compute_pkt_fields(AVFormatContext *s, AVStream *st,
     int64_t offset;
     AVRational duration;
     int onein_oneout = st->codecpar->codec_id != AV_CODEC_ID_H264 &&
-                       st->codecpar->codec_id != AV_CODEC_ID_HEVC;
+                       st->codecpar->codec_id != AV_CODEC_ID_HEVC &&
+                       st->codecpar->codec_id != AV_CODEC_ID_VVC;
 
     if (s->flags & AVFMT_FLAG_NOFILLIN)
         return;
